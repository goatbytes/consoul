{
  "created_at": "2025-12-23T12:11:18.417513Z",
  "updated_at": "2025-12-26T06:47:17.226216Z",
  "id": "SOUL-297",
  "uuid": "1852be34-45ba-45b0-a375-9bb06a11a3fa",
  "title": "Add HTTP chat endpoint with session management",
  "description": "**As a** frontend developer\n**I want** POST /chat endpoint with automatic session management\n**So that** I can integrate Consoul into web applications\n\n**Context:**\nLegal industry first deployment needs simple HTTP endpoint for document analysis. Current example (fastapi_sessions.py) shows pattern but needs productionization. Endpoint should:\n- Accept chat requests with session_id\n- Manage session lifecycle automatically\n- Support Redis or in-memory storage\n- Return structured responses\n\nPattern: Similar to OpenAI chat completions API for familiarity.\n\n**Technical Notes:**\n- Create: src/consoul/server/endpoints/chat.py\n- Create: src/consoul/server/models.py (Pydantic models)\n- Create: src/consoul/server/sessions.py (SessionStore)\n- Dependencies: redis (optional)\n- Integration: create_server() mounts POST /chat\n- Use: create_session() from SOUL-236\n\nRequest/Response models:\n- ChatRequest: session_id, message, model?, temperature?\n- ChatResponse: content, tokens, model, usage, session_id\n- ErrorResponse: error, message, details\n\nSessionStore implementations:\n- MemorySessionStore (development)\n- RedisSessionStore (production)\n\n**Acceptance Criteria:**\n\n**Given** server is running\n**When** I POST /chat with {\"session_id\": \"abc\", \"message\": \"Hello\"}\n**Then** returns ChatResponse with AI reply\n\n**Given** session exists in store\n**When** I send second message with same session_id\n**Then** conversation history is maintained\n\n**Given** session TTL expires\n**When** cleanup runs\n**Then** expired sessions are removed from store\n\n**Given** Redis is unavailable\n**When** using RedisSessionStore\n**Then** falls back to MemorySessionStore with warning log\n\n**Given** invalid request\n**When** POST /chat with missing fields\n**Then** returns 422 with Pydantic validation errors\n\n**Testing Considerations:**\n- Test session creation and retrieval\n- Test conversation continuity across requests\n- Test session TTL and cleanup\n- Test Redis connection failures\n- Test concurrent requests to same session\n- Mock create_session() in unit tests\n- Integration test with TestClient\n\n**Implementation Hints:**\n- SessionStore protocol with get/set/delete/cleanup methods\n- MemorySessionStore: Dict[str, tuple[Consoul, float]] with TTL\n- RedisSessionStore: Store session state in Redis with expiry\n- Endpoint: @router.post(\"/chat\", response_model=ChatResponse)\n- Use FastAPI dependency injection for SessionStore\n- Background task for session cleanup (periodic)\n- Add session count to /health endpoint\n- Document usage in examples/server/http_chat.py\n- Error handling: Wrap SDK exceptions in HTTPException\n- Reference: SOUL-236 for create_session() integration\n- Reference: SOUL-296 for factory integration",
  "status": "done",
  "type": "story",
  "priority": "high",
  "labels": [
    "server",
    "api",
    "http",
    "sessions"
  ],
  "assignee": "jared@goatbytes.io",
  "reporter": "jared@goatbytes.io",
  "epic_id": "EPIC-017",
  "blocked_by": [
    "SOUL-292",
    "SOUL-296"
  ],
  "blocks": [
    "SOUL-298",
    "SOUL-300"
  ],
  "comments": [
    {
      "created_at": "2025-12-25T06:45:13.948875Z",
      "updated_at": "2025-12-25T06:45:13.948878Z",
      "id": "20251224224513-8d850671",
      "ticket_id": "SOUL-297",
      "author": "jared@goatbytes.io",
      "content": "## Implementation Plan Update - Critical API & Architecture Fixes Required\n\nAfter code review with Codex, the original plan has **critical flaws** that must be addressed before implementation:\n\n### P1 Issues - Blocking Implementation\n\n1. **Incorrect SDK APIs Used**:\n   - \u274c Plan used `console.chat_stream()` - DOES NOT EXIST\n   - \u2705 Actual API: `console.chat(message)` returns string (blocking!)\n   - \u274c Plan used `token.usage_metadata` - DOES NOT EXIST  \n   - \u2705 Actual API: `Token.metadata` dict, `console.last_cost`, `console.model_name`\n   - \u274c Plan used `console.get_usage_metadata()` - DOES NOT EXIST\n   - \ud83d\udccd References: src/consoul/sdk/wrapper.py:712, src/consoul/sdk/models.py:24\n\n2. **Unsafe Session Serialization**:\n   - \u274c Plan proposed pickling Consoul objects - **RCE VULNERABILITY**\n   - Consoul contains non-serializable LangChain clients, locks, callbacks\n   - \u2705 Must use explicit JSON serialization of conversation history only\n   - \u2705 Rehydrate via create_session() with history restoration\n   - \ud83d\udccd Blocked by: **SOUL-304** (Session Store Safety)\n   - \ud83d\udccd References: src/consoul/sdk/wrapper.py:81, src/consoul/ai/history.py:815\n\n3. **Missing Concurrency Controls**:\n   - \u274c Plan allows concurrent requests to same session_id \u2192 race conditions\n   - Multiple requests can mutate conversation history simultaneously\n   - \u2705 Need per-session asyncio.Lock or request queue\n   - \ud83d\udccd Reference: src/consoul/sdk/wrapper.py:742\n\n### P2 Issues - Architecture Concerns\n\n4. **Silent Redis Fallback Breaks Multi-Worker**:\n   - \u274c Plan: \"Fallback to MemorySessionStore if Redis unavailable\"\n   - Problem: Sessions diverge across worker processes (split brain)\n   - \u2705 **Production**: Fail fast if Redis unavailable (no silent fallback)\n   - \u2705 **Development**: Opt-in fallback with loud warning\n\n5. **Redis URL Ambiguity**:\n   - Plan adds `redis_url` to ServerConfig\n   - Conflicts with existing `CONSOUL_REDIS_URL` for rate limiting\n   - \u2705 Use distinct env var: `CONSOUL_SESSION_REDIS_URL`\n   - \ud83d\udccd Blocked by: **SOUL-305** (Server Config Hygiene)\n\n6. **Blocking Event Loop**:\n   - Consoul.chat() is synchronous, blocks asyncio event loop\n   - \u2705 Use asyncio.to_thread() or switch to ConversationService.send_message()\n   - \ud83d\udccd Reference: src/consoul/sdk/wrapper.py:712\n\n### Architectural Decisions (from Codex Review)\n\n**Session TTL Strategy**: Sliding TTL with max lifetime cap\n- Refresh TTL on each request (better UX for active users)\n- Max lifetime cap (e.g., 24h) prevents unbounded growth\n- Helps compliance (data retention policies)\n\n**Redis Fallback Policy**:\n- Production: `allow_fallback=False` (default) - fail fast\n- Development: `allow_fallback=True` (opt-in) - with loud warning\n\n### Dependencies - Must Complete First\n\n1. \u2705 **SOUL-292** (Tool Filtering) - Complete\n2. \u2705 **SOUL-296** (Server Factory) - Complete\n3. \ud83d\udd34 **SOUL-304** (Session Store Safety) - **BLOCKING** - Must define safe serialization\n4. \ud83d\udfe1 **SOUL-305** (Server Config Hygiene) - Should fix Redis URL ambiguity\n5. \ud83d\udfe1 **SOUL-306** (Health/Readiness Contract) - Should standardize before adding session counts\n\n### Streaming Support Question\n\n**Do we need streaming before HTTP chat?**\n\nCurrent state:\n- SDK has `ConversationService.send_message()` which yields `Token` objects\n- This supports streaming but is async iterator pattern\n- HTTP endpoint would need to:\n  - Use Server-Sent Events (SSE) for streaming\n  - Or return complete response (simpler, acceptable for MVP)\n\n**Recommendation**: Start with **non-streaming** HTTP endpoint (complete response)\n- Simpler implementation, easier testing\n- Good enough for legal document analysis use case\n- Add streaming in SOUL-298 (WebSocket) or future SSE ticket\n\n### Revised Implementation Approach\n\n**Block implementation until**:\n1. SOUL-304 defines safe session serialization format\n2. SOUL-305 resolves Redis URL configuration\n3. Research actual SDK APIs (chat vs send_message, Token metadata)\n\n**Then implement with**:\n- Non-streaming endpoint (complete response)\n- Per-session locking for concurrency\n- Fail-fast Redis (no silent fallback in production)\n- Sliding TTL with max lifetime\n- Safe JSON serialization (history only, no pickle)\n\n**Example corrected endpoint**:\n```python\nasync def chat_endpoint(request: ChatRequest, store: SessionStore):\n    # Get per-session lock\n    async with store.get_lock(request.session_id):\n        console = await store.get(request.session_id)\n        if not console:\n            console = create_session(...)\n            await store.set(request.session_id, console)\n        \n        # Use asyncio.to_thread to avoid blocking event loop\n        response_text = await asyncio.to_thread(console.chat, request.message)\n        \n        return ChatResponse(\n            session_id=request.session_id,\n            content=response_text,\n            tokens=console.last_cost or 0,  # Correct API\n            model=console.model_name,       # Correct API\n        )\n```\n\nSee SOUL-304, SOUL-305, SOUL-306 for prerequisite work.",
      "edited": false,
      "edit_count": 0,
      "is_ai_generated": false,
      "attachments": [],
      "attachment_count": 0
    },
    {
      "created_at": "2025-12-26T06:40:36.582492Z",
      "updated_at": "2025-12-26T06:40:36.582495Z",
      "id": "20251225224036-be3fce8e",
      "ticket_id": "SOUL-297",
      "author": "jared@goatbytes.io",
      "content": "Implemented HTTP chat endpoint with session management:\n\n## Changes\n- Added ChatRequest, ChatResponse, ChatUsage, ChatErrorResponse models (src/consoul/server/models.py)\n- Created SessionLockManager for per-session async locking (src/consoul/server/session_locks.py)\n- Added session store initialization in factory with fail-fast Redis policy\n- Added POST /chat endpoint with authentication, rate limiting, and session persistence\n- Updated module exports in __init__.py\n\n## Critical Issues Addressed\n- P1: Wrapped all blocking calls (store.load, console.chat, store.save) in asyncio.to_thread()\n- P1: Added application-level SessionLockManager for atomic load\u2192chat\u2192save per session\n- P2: Documented error responses in OpenAPI with responses={}\n- P2: Added warning log when model parameter differs from existing session\n- P3: Limited message max_length to 32KB (32768)\n\n## Tests\n- Added 32 unit tests covering validation, auth, rate limiting, error handling, and session management\n- All 120 server tests pass",
      "edited": false,
      "edit_count": 0,
      "is_ai_generated": false,
      "attachments": [],
      "attachment_count": 0
    }
  ],
  "attachments": [],
  "attachment_count": 0,
  "comment_count": 2,
  "story_points": 5,
  "order": 0,
  "custom_fields": {},
  "_archive_metadata": {
    "archived_at": "2025-12-30T02:17:01.650235+00:00",
    "archived_from_status": "done",
    "archived_by": "gira-cli"
  }
}