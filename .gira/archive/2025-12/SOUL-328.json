{
  "created_at": "2025-12-30T02:05:46.129421Z",
  "updated_at": "2025-12-30T03:57:28.564586Z",
  "id": "SOUL-328",
  "uuid": "d8439e63-ee21-4dbc-91d8-03c8002bba71",
  "_version": 1,
  "title": "Add graceful Redis degradation with fallback to in-memory",
  "description": "**As a** Consoul server operator\n**I want** graceful Redis degradation with automatic fallback to in-memory storage\n**So that** my application continues operating (with reduced capability) when Redis is temporarily unavailable\n\n**Context:**\nThe server currently implements a fail-fast pattern when Redis is configured but unavailable (factory.py:360-364). While this is intentional for production safety, some deployments prefer degraded mode over total failure, especially during:\n- Development environments where Redis may restart frequently\n- Staging environments with less reliable infrastructure\n- Production scenarios where partial service is better than no service\n\nSimilar tools like Celery support `redis_socket_timeout` with connection retry, and FastAPI-limiter has fallback patterns. This feature should be opt-in (default: false) to preserve the current fail-fast behavior for production.\n\n**Technical Notes:**\n\n**Files to modify:**\n- `src/consoul/server/models.py` - Add `fallback_enabled` to SessionConfig and RateLimitConfig\n- `src/consoul/server/factory.py` - Implement fallback logic in session store and rate limiter initialization\n- Create new `src/consoul/server/redis_health.py` - Periodic reconnection logic and health monitoring\n\n**Current implementation (factory.py:348-370):**\n```python\nif config.session.redis_url:\n    try:\n        import redis\n        redis_client = redis.from_url(config.session.redis_url)\n        session_store = RedisSessionStore(...)\n    except Exception as e:\n        # FAIL-FAST: No silent fallback to memory in production\n        raise RuntimeError(...)\n```\n\n**Proposed architecture:**\n1. Add `CONSOUL_REDIS_FALLBACK_ENABLED` (default: false)\n2. Create `ResilientSessionStore` wrapper that:\n   - Wraps either Redis or Memory store\n   - Tracks current mode (redis|memory|degraded)\n   - Logs warnings when degraded\n   - Attempts periodic reconnection (configurable interval)\n3. Similar pattern for rate limiter using slowapi's storage abstraction\n4. Emit metrics via existing ObservabilityConfig (factory.py:231-263)\n\n**Session state considerations:**\n- When Redis was working and fails \u2192 sessions are LOST (critical warning)\n- When starting in degraded mode \u2192 sessions are ephemeral (warning)\n- When Redis recovers \u2192 new sessions use Redis, existing memory sessions continue until expire\n\n**Rate limiter considerations:**\n- slowapi supports memory storage as fallback\n- Rate limits reset on fallback (counts lost in Redis)\n- Rate limits reset again on recovery (counts in memory lost)\n\n**Environment variables:**\n- `CONSOUL_REDIS_FALLBACK_ENABLED=true|false` (default: false)\n- `CONSOUL_REDIS_RECONNECT_INTERVAL=60` (seconds, default: 60)\n- Applies to both session store and rate limiter\n\n**Acceptance Criteria:**\n\n**Given** `CONSOUL_REDIS_FALLBACK_ENABLED=false` (default)\n**When** Redis is configured but unavailable at startup\n**Then** server fails with RuntimeError (current behavior preserved)\n\n**Given** `CONSOUL_REDIS_FALLBACK_ENABLED=true`\n**When** Redis is configured but unavailable at startup\n**Then** server starts with MemorySessionStore and logs WARNING:\n  \"Redis unavailable - running in degraded mode with in-memory storage. Sessions will not persist across restarts.\"\n\n**Given** server running in degraded mode with fallback enabled\n**When** periodic health check detects Redis is available\n**Then** new sessions use Redis, log INFO: \"Redis connection recovered\"\n**And** metric `consoul_redis_recovered_total` increments\n\n**Given** server running with Redis working\n**When** Redis becomes unavailable mid-operation\n**Then** operation fails (no mid-request fallback - too complex)\n**And** readiness endpoint returns 503 with `{\"checks\": {\"redis\": false}}`\n\n**Given** server was using Redis successfully for sessions\n**When** Redis fails and fallback is enabled\n**Then** log CRITICAL: \"Redis connection lost - existing sessions are unavailable. New sessions will use in-memory storage (not distributed).\"\n\n**Given** fallback mode is active\n**When** GET /ready is called\n**Then** return 200 with `{\"status\": \"ready\", \"checks\": {\"redis\": \"degraded\"}, \"message\": \"Running in fallback mode\"}`\n\n**Testing Considerations:**\n- Unit tests for ResilientSessionStore wrapper\n- Test fallback_enabled=false preserves fail-fast (regression test)\n- Test fallback_enabled=true allows startup without Redis\n- Mock Redis to test reconnection logic\n- Test metrics emission on recovery\n- Integration test with actual Redis using testcontainers\n- Test session loss warning when Redis fails after working\n- Test rate limiter fallback to memory storage\n\n**Implementation Hints:**\n\n1. Add to `SessionConfig` (models.py):\n```python\nfallback_enabled: bool = Field(\n    default=False,\n    description=\"Fall back to in-memory when Redis unavailable (default: fail-fast)\",\n    validation_alias=\"CONSOUL_REDIS_FALLBACK_ENABLED\",\n)\nreconnect_interval: int = Field(\n    default=60,\n    ge=10,\n    le=3600,\n    description=\"Seconds between Redis reconnection attempts\",\n    validation_alias=\"CONSOUL_REDIS_RECONNECT_INTERVAL\",\n)\n```\n\n2. Create `ResilientSessionStore` wrapper in `src/consoul/server/resilient_store.py`:\n```python\nclass ResilientSessionStore:\n    \"\"\"SessionStore with automatic Redis fallback and recovery.\"\"\"\n    \n    def __init__(\n        self,\n        redis_url: str,\n        ttl: int,\n        prefix: str,\n        fallback_enabled: bool,\n        reconnect_interval: int,\n    ):\n        self._redis_url = redis_url\n        self._fallback_enabled = fallback_enabled\n        self._reconnect_interval = reconnect_interval\n        self._mode: Literal[\"redis\", \"memory\", \"degraded\"] = \"redis\"\n        self._primary: RedisSessionStore | None = None\n        self._fallback = MemorySessionStore(ttl=ttl)\n        self._last_check = 0.0\n        self._initialize()\n```\n\n3. Update factory.py to use ResilientSessionStore when fallback enabled\n4. Add Prometheus metric in observability.py:\n   - `consoul_redis_degraded` (gauge: 1 if degraded, 0 if healthy)\n   - `consoul_redis_recovered_total` (counter)\n5. Update /ready endpoint to show degraded status appropriately\n\n**Dependencies:**\n- SOUL-305 (standardize Redis env vars) - DONE\n- SOUL-306 (health endpoint schema) - DONE\n\n**Out of scope:**\n- Mid-request failover (too complex, may cause inconsistent state)\n- Session migration from Redis to memory on failure (data already lost)\n- Distributed in-memory fallback (contradicts purpose)",
  "status": "done",
  "type": "feature",
  "priority": "medium",
  "labels": [
    "server",
    "redis",
    "resilience",
    "reliability"
  ],
  "assignee": "jared@goatbytes.io",
  "reporter": "jared@goatbytes.io",
  "epic_id": "EPIC-017",
  "blocked_by": [],
  "blocks": [],
  "comments": [],
  "attachments": [],
  "attachment_count": 0,
  "comment_count": 0,
  "story_points": 5,
  "order": 0,
  "custom_fields": {},
  "_archive_metadata": {
    "archived_at": "2025-12-30T19:52:07.009021+00:00",
    "archived_from_status": "done",
    "archived_by": "gira-cli"
  }
}