{
  "created_at": "2025-12-30T02:06:11.394217Z",
  "updated_at": "2025-12-30T02:15:39.224676Z",
  "id": "SOUL-331",
  "uuid": "0b1154c9-611d-4141-bfd1-d08d26144f0f",
  "title": "Add per-API-key rate limit tiers",
  "description": "**As a** Consoul server administrator\n**I want** different rate limit tiers based on API key patterns\n**So that** I can offer premium customers higher limits while protecting the system from abuse by basic tier users\n\n**Context:**\nCurrent rate limiting in `src/consoul/server/middleware/rate_limit.py` uses slowapi with global limits configured via `CONSOUL_DEFAULT_LIMITS`. All API keys receive the same rate limit regardless of customer tier. Enterprise deployments need differentiated limits (e.g., basic: 30/min, premium: 100/min, enterprise: unlimited).\n\nSlowapi supports dynamic rate limits via callable functions in the `@limiter.limit()` decorator. The callable receives the request and can return different limit strings based on API key patterns. This pattern is documented in [slowapi GitHub Issue #13](https://github.com/laurentS/slowapi/issues/13).\n\nSimilar tools (OpenAI API, Anthropic API) use API key prefixes to identify tier levels (e.g., `sk-proj-*` vs `sk-org-*`).\n\n**Technical Notes:**\n\nFiles to modify:\n- `src/consoul/server/models.py` (lines 402-467): Extend `RateLimitConfig` with tier fields\n- `src/consoul/server/middleware/rate_limit.py`: Add `TieredRateLimiter` class\n- `src/consoul/server/factory.py` (lines 291-307): Use tiered limiter when tiers configured\n\nConfiguration Model (add to `RateLimitConfig`):\n```python\ntier_limits: dict[str, str] | None = Field(\n    default=None,\n    description=\"Rate limit tiers mapping tier name to limit string\",\n    validation_alias=\"CONSOUL_RATE_LIMIT_TIERS\",\n    # JSON: '{\"premium\": \"100/minute\", \"basic\": \"30/minute\"}'\n)\napi_key_tiers: dict[str, str] | None = Field(\n    default=None,\n    description=\"API key patterns to tier mapping (supports wildcards)\",\n    validation_alias=\"CONSOUL_API_KEY_TIERS\",\n    # JSON: '{\"sk-premium-*\": \"premium\", \"sk-basic-*\": \"basic\"}'\n)\n```\n\nUse Pydantic validators to parse JSON from environment variables (similar to existing `parse_comma_separated_list` pattern at line 42).\n\nDynamic Limit Function Pattern:\n```python\ndef create_tiered_limit_func(\n    tier_limits: dict[str, str],\n    api_key_tiers: dict[str, str],\n    default_limit: str,\n    header_name: str = \"X-API-Key\"\n) -> Callable[[Request], str]:\n    \"\"\"Create dynamic limit function based on API key tier.\"\"\"\n    import fnmatch\n    \n    def get_limit(request: Request) -> str:\n        api_key = request.headers.get(header_name, \"\")\n        for pattern, tier in api_key_tiers.items():\n            if fnmatch.fnmatch(api_key, pattern):\n                return tier_limits.get(tier, default_limit)\n        return default_limit\n    \n    return get_limit\n```\n\nIntegration Points:\n- Extend `RateLimiter.__init__()` to accept tier configuration\n- Add `create_tiered_api_key_limiter()` factory function\n- Update `create_app()` in factory.py to pass tier config to limiter\n\n**Acceptance Criteria:**\n\n**Given** I configure tiers via environment variables:\n```\nCONSOUL_RATE_LIMIT_TIERS='{\"premium\": \"100/minute\", \"basic\": \"30/minute\"}'\nCONSOUL_API_KEY_TIERS='{\"sk-premium-*\": \"premium\", \"sk-basic-*\": \"basic\"}'\n```\n**When** a request arrives with header `X-API-Key: sk-premium-abc123`\n**Then** the request is rate limited at 100/minute\n\n**Given** I configure tier limits as above\n**When** a request arrives with header `X-API-Key: sk-basic-xyz789`\n**Then** the request is rate limited at 30/minute\n\n**Given** I configure tier limits but an API key matches no pattern\n**When** the request arrives with `X-API-Key: sk-unknown-123`\n**Then** the default limit (`CONSOUL_DEFAULT_LIMITS`) is applied\n\n**Given** I do NOT configure any tier settings\n**When** the server starts\n**Then** existing behavior is preserved (global limits for all keys)\n\n**Given** I configure an invalid JSON string for `CONSOUL_RATE_LIMIT_TIERS`\n**When** `RateLimitConfig` is instantiated\n**Then** a `ValidationError` is raised with clear error message\n\n**Given** a tier name in `api_key_tiers` does not exist in `tier_limits`\n**When** the server processes requests\n**Then** fallback to default limit (log warning about missing tier)\n\n**Testing Considerations:**\n- Unit tests for `parse_json_dict()` validator with valid/invalid JSON\n- Unit tests for `create_tiered_limit_func()` with various patterns\n- Test wildcard matching: `sk-*`, `*-premium-*`, exact matches\n- Integration test with FastAPI TestClient verifying different keys get different limits\n- Test backward compatibility: no tier config = existing behavior\n- Test Redis storage with tiers (distributed rate limiting)\n- Mock slowapi Limiter for unit tests\n\n**Implementation Hints:**\n1. Add `parse_json_dict()` validator in models.py (similar to `parse_comma_separated_list` at line 42):\n   ```python\n   def parse_json_dict(v: str | dict | None) -> dict | None:\n       if v is None:\n           return None\n       if isinstance(v, dict):\n           return v\n       if isinstance(v, str):\n           try:\n               return json.loads(v)\n           except json.JSONDecodeError as e:\n               raise ValueError(f\"Invalid JSON: {e}\") from e\n       return None\n   ```\n\n2. Use `fnmatch.fnmatch()` for glob-style pattern matching (standard library)\n\n3. Consider adding `exempt_tiers` field for enterprise keys that bypass limits entirely:\n   ```python\n   @limiter.limit(get_limit, exempt_when=is_exempt_tier)\n   ```\n\n4. Store resolved tier in `request.state.rate_limit_tier` for logging/debugging\n\n5. Add tier info to rate limit exceeded response for debugging\n\n6. Document tier configuration in server factory docstring (lines 35-37 reference)\n\n7. Consider pattern priority: first match wins (document this behavior)\n\n**Out of Scope:**\n- Per-endpoint tier overrides (future enhancement)\n- Database-backed tier lookups (would need async support)\n- Runtime tier changes without restart (requires Redis pub/sub)",
  "status": "backlog",
  "type": "feature",
  "priority": "medium",
  "labels": [
    "server",
    "rate-limiting",
    "enhancement"
  ],
  "assignee": "jared@goatbytes.io",
  "reporter": "jared@goatbytes.io",
  "epic_id": "EPIC-017",
  "blocked_by": [],
  "blocks": [],
  "comments": [],
  "attachments": [],
  "attachment_count": 0,
  "comment_count": 0,
  "story_points": 5,
  "order": 0,
  "custom_fields": {},
  "_version": 1
}