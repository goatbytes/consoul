{
  "created_at": "2025-11-14T22:30:23.840580",
  "updated_at": "2025-11-15T00:00:10.169228",
  "id": "SOUL-104",
  "uuid": "11ce9282-925b-4ffe-8644-775a5b4fc44e",
  "title": "Implement core EditEngine with line-based editing",
  "description": "**As a** Consoul AI agent\n**I want** to edit files using line-range specifications\n**So that** I can make precise, atomic code changes without rewriting entire files\n\n**Context:**\nLine-based editing is the foundation for AI file manipulation. Research from cursor-agent, wcgw, and aider shows that line-range edits ({\"1-5\": \"new content\"}) are:\n- More precise than full-file rewrites\n- Easier for LLMs to generate correctly\n- Safer (edits are scoped and atomic)\n- Faster (only changed lines are processed)\n\nThis ticket implements the core EditEngine with exact matching only. Progressive matching (whitespace/fuzzy) comes in SOUL-106.\n\nSee research:\n- docs/research/line_based_file_editing_research.md\n- cursor-agent: cursor_agent_tools/tools/file_tools.py:426-505\n- SOUL-90 (research ticket)\n\n**Technical Notes:**\n- Create src/consoul/ai/tools/implementations/file_edit.py\n- Implement EditEngine class with validate_edits(), apply_line_edits()\n- Process edits bottom-to-top (preserves line numbers, per cursor-agent pattern)\n- Support single lines (\"42\") and ranges (\"10-15\")\n- Atomic writes (temp file → replace to prevent corruption)\n- Return structured FileEditResult with checksum, changed_lines, preview diff\n- Integrate with ToolRegistry (RiskLevel.CAUTION)\n- Use FileEditToolConfig from SOUL-103\n\nAlgorithm (from cursor-agent):\n```python\ndef apply_line_based_edit(content: str, line_edits: Dict[str, str]) -> str:\n    lines = content.splitlines()\n    \n    # Sort ranges descending to avoid index drift\n    for line_range in sorted(line_edits.keys(), reverse=True):\n        start, end = parse_range(line_range)\n        new_content = line_edits[line_range].splitlines()\n        lines[start-1:end] = new_content\n    \n    return \"\\n\".join(lines)\n```\n\nFiles to create:\n- src/consoul/ai/tools/implementations/file_edit.py\n\nFiles to modify:\n- src/consoul/ai/tools/implementations/__init__.py (export edit_file_lines)\n\n**Acceptance Criteria:**\n\n**Given** I have a file with 10 lines\n**When** I edit lines 3-5 with new content\n**Then** only lines 3-5 are replaced and other lines unchanged\n\n**Given** I specify multiple non-overlapping edits {\"1-2\": \"...\", \"8-9\": \"...\"}\n**When** edits are applied\n**Then** all edits succeed and line numbers remain stable (bottom-to-top processing)\n\n**Given** I specify invalid line range (start > end or out of bounds)\n**When** validation runs\n**Then** I get clear error message with file line count\n\n**Given** file content changed since read (different checksum)\n**When** I provide expected_hash that doesn't match\n**Then** edit fails with \"File changed since read\" error\n\n**Given** I request dry_run=True\n**When** edits are processed\n**Then** I get preview diff without modifying the file\n\n**Given** edit payload exceeds max_payload_bytes\n**When** validation runs\n**Then** edit is rejected with size limit error\n\n**Testing Considerations:**\n- Unit tests for range parsing (\"1\", \"5-10\", \"100-100\")\n- Test bottom-to-top processing order\n- Test overlapping range detection and rejection\n- Mock file I/O for deterministic tests\n- Test atomic write (temp file → replace)\n- Test checksum validation\n- Test dry-run mode\n- Test size limits from config\n\n**Implementation Hints:**\n```python\n@dataclass\nclass LineEditOperation:\n    range: str  # \"1-5\" or \"42\"\n    content: str\n    expect: str | None = None  # Optional expected content for validation\n\n@dataclass  \nclass FileEditResult:\n    status: Literal[\"success\", \"validation_failed\", \"hash_mismatch\", \"error\"]\n    bytes_written: int | None\n    checksum: str | None  # SHA256\n    changed_lines: list[str]  # [\"3-5\", \"8-9\"]\n    preview: str  # Unified diff\n    warnings: list[str]\n\n@tool\ndef edit_file_lines(\n    file_path: str,\n    line_edits: Dict[str, str],\n    expected_hash: str | None = None,\n    dry_run: bool = False,\n) -> str:\n    # Load config, validate path, compute hash, apply edits, atomic write\n```\n\nUse hashlib.sha256 for checksums\nUse difflib.unified_diff for previews\nUse pathlib.Path for atomic writes",
  "status": "done",
  "type": "feature",
  "priority": "high",
  "labels": [
    "file-edit",
    "core",
    "foundation"
  ],
  "assignee": "jared@goatbytes.io",
  "reporter": "jared@goatbytes.io",
  "epic_id": "EPIC-005",
  "blocked_by": [
    "SOUL-103"
  ],
  "blocks": [
    "SOUL-105",
    "SOUL-106",
    "SOUL-107",
    "SOUL-108",
    "SOUL-109",
    "SOUL-111"
  ],
  "comments": [
    {
      "created_at": "2025-11-15T00:00:10.169140",
      "updated_at": "2025-11-15T00:00:10.169142",
      "id": "20251115000010-7bc26843",
      "ticket_id": "SOUL-104",
      "author": "jared@goatbytes.io",
      "content": "✅ SOUL-104 Implementation Complete\n\n## Summary\nSuccessfully implemented the core EditEngine with comprehensive line-based file editing capabilities for Consoul AI.\n\n## Changes Implemented\n\n### 1. file_edit.py - Core Implementation (586 lines)\n\n**Module-Level Config Management:**\n- `set_file_edit_config()` / `get_file_edit_config()` - Config injection by ToolRegistry\n- Module-global `_TOOL_CONFIG` pattern matching read.py and bash.py\n\n**FileEditResult Dataclass:**\n- Structured JSON results with status, bytes_written, checksum, changed_lines, preview, warnings, error fields\n- `.to_json()` method for LLM-friendly responses\n\n**8 Core Functions:**\n\n1. **_parse_line_range** (lines 92-137)\n   - Parses \"42\" or \"1-5\" formats\n   - Validates positive integers only (rejects negative numbers)\n   - Returns (start, end) tuple (1-indexed, inclusive)\n\n2. **_validate_file_path** (lines 140-199)\n   - Security validation: path traversal blocking, extension allowlist, blocked paths\n   - File existence check\n   - Shared validation pattern with ReadToolConfig\n\n3. **_compute_file_hash** (lines 202-213)\n   - SHA256 hash computation for optimistic locking\n   - Returns hex digest for content verification\n\n4. **_validate_edits** (lines 216-292)\n   - max_edits, max_payload_bytes enforcement\n   - Overlapping range detection\n   - Out-of-bounds line number checking\n   - Returns detailed error messages\n\n5. **_apply_line_edits** (lines 295-343)\n   - **Bottom-to-top processing** (cursor-agent pattern)\n   - Sorts ranges descending to preserve line numbers\n   - Returns (result_lines, changed_ranges)\n\n6. **_create_diff_preview** (lines 346-364)\n   - Uses difflib.unified_diff for human-readable diffs\n   - Shows context around changes\n\n7. **_atomic_write** (lines 367-392)\n   - Temp file + rename pattern prevents corruption\n   - Ensures atomic file replacement\n   - Auto-cleanup on errors\n\n8. **edit_file_lines** (lines 435-586)\n   - @tool decorated function for LangChain integration\n   - EditFileLinesInput Pydantic schema for validation\n   - Comprehensive workflow: validate → read → lock check → apply → diff → write\n   - Newline preservation logic (lines 541-544)\n   - Returns JSON FileEditResult\n\n### 2. __init__.py - Exports (3 additions)\n- `edit_file_lines` function\n- `get_file_edit_config` function\n- `set_file_edit_config` function\n\n### 3. test_file_edit.py - Comprehensive Test Suite (797 lines, 63 tests)\n\n**Test Classes:**\n1. TestParseLineRange (8 tests) - Line range parsing edge cases\n2. TestValidateFilePath (8 tests) - Security validation\n3. TestComputeFileHash (3 tests) - Hash computation\n4. TestValidateEdits (9 tests) - Edit validation logic\n5. TestApplyLineEdits (10 tests) - Bottom-to-top processing\n6. TestCreateDiffPreview (4 tests) - Diff generation\n7. TestAtomicWrite (4 tests) - Atomic file operations\n8. TestEditFileLines (14 tests) - Integration tests\n9. TestFileEditResult (2 tests) - Dataclass serialization\n10. TestModuleConfig (2 tests) - Config management\n\n**Key Test Patterns:**\n- Uses `.invoke()` for LangChain StructuredTool calls\n- Validates JSON responses with status, changed_lines, checksum\n- Tests security (path traversal, extension blocking, blocked paths)\n- Tests optimistic locking (expected_hash mismatch)\n- Tests dry_run preview mode\n- Tests newline preservation\n- Tests bottom-to-top processing correctness\n\n## Test Results\n\n### Pytest (100% Pass Rate)\n```\n✅ 63/63 tests passing in 3.53s\n```\n\n### Type Checking\n```\n✅ mypy: Success - no issues found in file_edit.py\n```\n\n### Linting\n```\n✅ ruff: All checks passed\n```\n\n## Acceptance Criteria Met\n\n✅ **Given** I call edit_file_lines with valid line edits  \n**When** Processing occurs  \n**Then** Lines are edited exactly as specified\n\n✅ **Given** I edit line 1 then line 10  \n**When** Using bottom-to-top processing  \n**Then** Line 10 is edited first to preserve line 1's position\n\n✅ **Given** I provide expected_hash matching file content  \n**When** Editing occurs  \n**Then** Edit succeeds with new checksum returned\n\n✅ **Given** I provide mismatched expected_hash  \n**When** Validation occurs  \n**Then** Edit fails with hash_mismatch status\n\n✅ **Given** I specify overlapping line ranges  \n**When** Validation occurs  \n**Then** Edit fails with validation_failed status\n\n✅ **Given** I use dry_run=True  \n**When** Processing occurs  \n**Then** Diff preview is returned without modifying file\n\n✅ **Given** I attempt path traversal  \n**When** Security validation occurs  \n**Then** Edit fails with validation_failed status\n\n## Technical Highlights\n\n### Bottom-to-Top Processing Algorithm\nFrom cursor-agent reference (lines 426-505), sorts ranges descending:\n```python\nsorted_ranges = sorted(\n    line_edits.keys(),\n    key=lambda r: _parse_line_range(r)[0],\n    reverse=True,\n)\n```\nThis ensures edits at line 100 don't shift line numbers at line 10.\n\n### Newline Preservation\nFixed subtle bug where files with trailing newlines lost them:\n```python\nif original_content.endswith(\"\\n\"):\n    new_content = \"\\n\".join(new_lines) + \"\\n\"\nelse:\n    new_content = \"\\n\".join(new_lines)\n```\n\n### LangChain Integration\n@tool decorator wraps function into StructuredTool requiring `.invoke()`:\n```python\nresult = edit_file_lines.invoke({\n    \"file_path\": str(file),\n    \"line_edits\": {\"3\": \"NEW LINE 3\"},\n})\n```\n\n## Files Modified\n- `src/consoul/ai/tools/implementations/file_edit.py` (+586 lines)\n- `src/consoul/ai/tools/implementations/__init__.py` (+8 lines)\n- `tests/ai/tools/implementations/test_file_edit.py` (+797 lines)\n- **Total**: +1391 lines\n\n## Commit\n- **SHA**: 2780c1b41e284404bb0c7d97e2c7c7345a76d277\n- **Message**: feat(SOUL-104): implement core EditEngine with line-based editing\n\n## Next Steps\nReady for downstream tickets that depend on SOUL-104:\n- SOUL-105: Integrate EditEngine into Consoul TUI\n- SOUL-106: Implement progressive matching for edit_file\n- SOUL-107: Add create_file tool\n- SOUL-108: Add delete_file tool\n- SOUL-109: Add move_file tool\n- SOUL-110: Comprehensive integration tests\n\n## Story Points\nCompleted in **8 points** (as estimated)",
      "edited": false,
      "edit_count": 0,
      "is_ai_generated": false,
      "attachments": [],
      "attachment_count": 0
    }
  ],
  "attachments": [],
  "attachment_count": 0,
  "comment_count": 1,
  "story_points": 8,
  "order": 0,
  "custom_fields": {}
}