{
  "created_at": "2025-11-20T12:10:11.905053",
  "updated_at": "2025-11-23T05:54:09.009512Z",
  "id": "SOUL-137",
  "uuid": "cd5903a9-d021-4477-be43-dc6881d23110",
  "title": "Add image attachment button to TUI input area",
  "description": "**As a** Consoul user\n**I want** an explicit attachment button in the TUI to add files to my messages\n**So that** I can easily share images, code, documents, and other files with the AI without typing file paths manually\n\n**Context:**\nWhile SOUL-116 added automatic image path detection, many users prefer explicit attachment UI. Modern AI assistants support multiple file types:\n- **Images**: Screenshots, diagrams, mockups (.png, .jpg, .gif, .webp)\n- **Documents**: PDFs, markdown, text files (.pdf, .md, .txt)\n- **Code**: Source files for review (.py, .js, .rs, .go, etc.)\n- **Data**: JSON, CSV, YAML configuration files\n\nThis provides:\n- **Better discoverability**: Visual button shows file support\n- **Ease of use**: File picker instead of typing paths\n- **Multiple file selection**: Attach several files at once\n- **Visual feedback**: See attached files before sending\n- **Accessibility**: Clearer for non-technical users\n- **Universal support**: Images use vision, text files use read tool\n\nModern reference patterns:\n- Slack/Discord: ðŸ“Ž attachment button for any file type\n- GitHub comments: Drag-and-drop + attachment button\n- ChatGPT web UI: Supports images, PDFs, code files\n- Claude.ai: Multi-file upload with format detection\n\n**Technical Notes:**\nResearch shows Textual patterns for file selection:\n- src/consoul/tui/widgets/input_area.py:81 - Current InputArea\n- src/consoul/tui/widgets/export_modal.py - Modal pattern with Buttons\n- Textual doesn't have native file picker, use tkinter.filedialog\n- Alternative: command palette approach (/attach command)\n\nArchitecture:\n1. New widget: src/consoul/tui/widgets/attachment_button.py\n   - Button with ðŸ“Ž icon\n   - Opens file picker on click\n   - Supports multiple file types\n   - Emits AttachmentSelected message\n\n2. New widget: src/consoul/tui/widgets/file_chip.py (renamed from image_chip.py)\n   - Display attached file with icon based on type\n   - Icons: ðŸ–¼ï¸ (image), ðŸ“„ (document), ðŸ’¾ (code), ðŸ“Š (data)\n   - Remove button (Ã—)\n   - File size indicator\n   - Optional: hover preview for text files\n\n3. Modify: src/consoul/tui/widgets/input_area.py\n   - Add attachment button to compose()\n   - Add container for file chips\n   - Track attached_files list with metadata\n   - Pass to MessageSubmit event\n   - Validate files by type\n\n4. Modify: src/consoul/tui/app.py:979\n   - Update on_input_area_message_submit()\n   - Separate images from text files\n   - Images: use multimodal vision messages\n   - Text files: include content in context or use read tool\n   - Combine with auto_detected paths\n   - Deduplicate files\n\nConfiguration integration:\n- Respects tool.image_analysis.enabled for images\n- Respects tool.read.allowed_extensions for text files\n- Validates against max_images_per_query for images\n- Validates against max_file_size for all files\n- Enforces blocked_paths security\n- Option to disable attachment button entirely\n\nFile type handling strategy:\n1. **Images** (.png, .jpg, .gif, .webp, .bmp):\n   - Use vision/multimodal messages (existing SOUL-116 flow)\n   - Send as base64 to vision-capable models\n   \n2. **Text files** (.py, .js, .md, .txt, etc.):\n   - Option A: Auto-include content in message context\n   - Option B: Use read_file tool automatically\n   - Option C: Show preview, user confirms inclusion\n   \n3. **PDFs** (.pdf):\n   - Use read tool with PDF extraction\n   - Show page count, allow page range selection\n   \n4. **Unsupported files**:\n   - Show error with supported types list\n   - Suggest using read tool manually\n\n**Acceptance Criteria:**\n\n**Given** I'm in the TUI chat interface\n**When** I look at the input area\n**Then** I see a ðŸ“Ž attachment button next to the text area\n\n**Given** I click the attachment button\n**When** file picker opens\n**Then** I can select multiple file types (images, code, docs, PDFs)\n\n**Given** I select 1 image and 1 Python file\n**When** selection completes\n**Then** I see 2 file chips: ðŸ–¼ï¸ screenshot.png, ðŸ’¾ main.py\n\n**Given** I have files attached\n**When** I click the Ã— on a file chip\n**Then** that file is removed from attachments\n\n**Given** I attach an image file\n**When** I press Enter to send\n**Then** the image is sent via multimodal vision message\n\n**Given** I attach a Python file\n**When** I press Enter to send\n**Then** the file content is included in context (or via read tool)\n\n**Given** I attach 1 image AND type \"screenshot.png\" in message\n**When** auto_detect_in_messages is enabled\n**Then** files are deduplicated and sent (no duplicates)\n\n**Given** I try to attach > max_images_per_query images\n**When** selection would exceed limit\n**Then** I get error: \"Maximum N images per message\"\n\n**Given** I try to attach a 10MB PDF\n**When** file exceeds size limit\n**Then** file chip shows error indicator with tooltip\n\n**Given** I try to attach an .exe file\n**When** file type is not allowed\n**Then** I get error: \"Unsupported file type. Supported: ...\"\n\n**Given** image_analysis tool is disabled in config\n**When** I try to attach an image file\n**Then** attachment succeeds but warning shown: \"Vision disabled, image will be described by filename only\"\n\n**Testing Considerations:**\n- Mock tkinter.filedialog for unit tests\n- Test AttachmentButton message posting\n- Test FileChip rendering with different file types\n- Test icon selection logic (image vs code vs doc)\n- Test InputArea tracks attached files correctly\n- Test integration with existing auto-detection\n- Test deduplication logic\n- Test file type routing (vision vs read tool)\n- Test config validation (max size, max count, allowed types)\n- Test error states (too large, wrong format, blocked path)\n- Manual TUI testing with various file types\n\n**Implementation Hints:**\n\nFile structure:\n```\nsrc/consoul/tui/widgets/\nâ”œâ”€â”€ attachment_button.py  # New\nâ”œâ”€â”€ file_chip.py          # New (was image_chip.py)\nâ””â”€â”€ input_area.py         # Modified\n```\n\nattachment_button.py skeleton:\n```python\nfrom textual.widgets import Button\nfrom textual.message import Message\nfrom pathlib import Path\n\nclass AttachmentButton(Button):\n    \"\"\"Button to attach files via file picker.\"\"\"\n    \n    class AttachmentSelected(Message):\n        def __init__(self, file_paths: list[str]) -> None:\n            self.file_paths = file_paths\n            super().__init__()\n    \n    def __init__(self) -> None:\n        super().__init__(\"ðŸ“Ž\", id=\"attachment-button\")\n    \n    async def on_button_pressed(self) -> None:\n        paths = await self._open_file_picker()\n        if paths:\n            self.post_message(self.AttachmentSelected(paths))\n    \n    async def _open_file_picker(self) -> list[str]:\n        # Run tkinter in executor to avoid blocking\n        import tkinter as tk\n        from tkinter import filedialog\n        \n        def _picker():\n            root = tk.Tk()\n            root.withdraw()\n            paths = filedialog.askopenfilenames(\n                title=\"Attach Files\",\n                filetypes=[\n                    (\"Images\", \"*.png *.jpg *.jpeg *.gif *.webp *.bmp\"),\n                    (\"Code\", \"*.py *.js *.ts *.rs *.go *.java *.cpp *.c *.h\"),\n                    (\"Documents\", \"*.pdf *.md *.txt *.rst\"),\n                    (\"Data\", \"*.json *.yaml *.yml *.csv *.xml\"),\n                    (\"All files\", \"*.*\")\n                ]\n            )\n            root.destroy()\n            return list(paths)\n        \n        import asyncio\n        loop = asyncio.get_event_loop()\n        return await loop.run_in_executor(None, _picker)\n```\n\nfile_chip.py skeleton:\n```python\nfrom textual.containers import Horizontal\nfrom textual.widgets import Label, Button\nfrom textual.message import Message\nfrom pathlib import Path\n\nclass FileChip(Horizontal):\n    \"\"\"Display attached file with type-specific icon and remove button.\"\"\"\n    \n    class RemoveRequested(Message):\n        def __init__(self, file_path: str) -> None:\n            self.file_path = file_path\n            super().__init__()\n    \n    def __init__(self, file_path: str, file_type: str = \"unknown\") -> None:\n        super().__init__()\n        self.file_path = file_path\n        self.file_type = file_type\n    \n    def compose(self):\n        filename = Path(self.file_path).name\n        icon = self._get_file_icon(self.file_type)\n        \n        # Get file size\n        try:\n            size = Path(self.file_path).stat().st_size\n            size_str = self._format_size(size)\n            yield Label(f\"{icon} {filename} ({size_str})\")\n        except:\n            yield Label(f\"{icon} {filename}\")\n        \n        yield Button(\"Ã—\", id=\"remove-chip\")\n    \n    def _get_file_icon(self, file_type: str) -> str:\n        \"\"\"Get emoji icon based on file type.\"\"\"\n        icons = {\n            \"image\": \"ðŸ–¼ï¸\",\n            \"code\": \"ðŸ’¾\",\n            \"document\": \"ðŸ“„\",\n            \"data\": \"ðŸ“Š\",\n            \"unknown\": \"ðŸ“Ž\"\n        }\n        return icons.get(file_type, \"ðŸ“Ž\")\n    \n    def _format_size(self, size: int) -> str:\n        \"\"\"Format file size in human-readable format.\"\"\"\n        if size < 1024:\n            return f\"{size}B\"\n        elif size < 1024 * 1024:\n            return f\"{size / 1024:.1f}KB\"\n        else:\n            return f\"{size / (1024 * 1024):.1f}MB\"\n    \n    def on_button_pressed(self, event: Button.Pressed) -> None:\n        if event.button.id == \"remove-chip\":\n            self.post_message(self.RemoveRequested(self.file_path))\n            self.remove()\n```\n\ninput_area.py modifications:\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass AttachedFile:\n    \"\"\"Metadata for an attached file.\"\"\"\n    path: str\n    type: str  # \"image\", \"code\", \"document\", \"data\"\n    mime_type: str\n    size: int\n\nclass InputArea(Container):\n    def __init__(self):\n        super().__init__()\n        self.attached_files: list[AttachedFile] = []\n    \n    def compose(self):\n        with Vertical():\n            with Horizontal(id=\"input-controls\"):\n                yield AttachmentButton()\n                yield self.text_area\n            with Horizontal(id=\"file-chips-container\"):\n                pass  # Dynamically populated\n    \n    def _classify_file(self, path: str) -> str:\n        \"\"\"Classify file by extension.\"\"\"\n        ext = Path(path).suffix.lower()\n        \n        if ext in {\".png\", \".jpg\", \".jpeg\", \".gif\", \".webp\", \".bmp\"}:\n            return \"image\"\n        elif ext in {\".py\", \".js\", \".ts\", \".rs\", \".go\", \".java\", \".cpp\", \".c\"}:\n            return \"code\"\n        elif ext in {\".pdf\", \".md\", \".txt\", \".rst\"}:\n            return \"document\"\n        elif ext in {\".json\", \".yaml\", \".yml\", \".csv\", \".xml\"}:\n            return \"data\"\n        else:\n            return \"unknown\"\n    \n    def on_attachment_button_attachment_selected(\n        self, event: AttachmentButton.AttachmentSelected\n    ) -> None:\n        config = self.app.consoul_config.tool\n        \n        for path in event.file_paths:\n            file_type = self._classify_file(path)\n            \n            # Validate images\n            if file_type == \"image\":\n                if not config.image_analysis.enabled:\n                    self.app.notify(\n                        \"Image analysis is disabled. Image will be referenced by filename only.\",\n                        severity=\"warning\"\n                    )\n                \n                # Check image-specific limits\n                image_count = sum(1 for f in self.attached_files if f.type == \"image\")\n                if image_count >= config.image_analysis.max_images_per_query:\n                    self.app.notify(\n                        f\"Maximum {config.image_analysis.max_images_per_query} images per message\",\n                        severity=\"error\"\n                    )\n                    continue\n            \n            # Validate file existence and size\n            try:\n                path_obj = Path(path)\n                if not path_obj.exists():\n                    self.app.notify(f\"File not found: {path}\", severity=\"error\")\n                    continue\n                \n                size = path_obj.stat().st_size\n                max_size = 20 * 1024 * 1024  # 20MB limit\n                \n                if size > max_size:\n                    self.app.notify(\n                        f\"File too large: {path_obj.name} ({size / (1024*1024):.1f}MB > 20MB)\",\n                        severity=\"error\"\n                    )\n                    continue\n                \n                # Add to attached files\n                self.attached_files.append(AttachedFile(\n                    path=path,\n                    type=file_type,\n                    mime_type=mimetypes.guess_type(path)[0] or \"application/octet-stream\",\n                    size=size\n                ))\n                \n            except Exception as e:\n                self.app.notify(f\"Error reading file: {e}\", severity=\"error\")\n                continue\n        \n        self._update_file_chips()\n    \n    def _update_file_chips(self) -> None:\n        container = self.query_one(\"#file-chips-container\")\n        container.remove_children()\n        for file in self.attached_files:\n            container.mount(FileChip(file.path, file.type))\n```\n\napp.py modifications (line ~979):\n```python\n# In on_input_area_message_submit:\n\n# Get attached files from UI\nattached_files = self.input_area.attached_files\n\n# Separate images from text files\nimage_files = [f for f in attached_files if f.type == \"image\"]\ntext_files = [f for f in attached_files if f.type != \"image\"]\n\n# Get auto-detected images from message text\nif auto_detect_enabled:\n    _, auto_detected = extract_image_paths(user_message)\nelse:\n    auto_detected = []\n\n# Combine and deduplicate images\nall_images = list(set([f.path for f in image_files] + auto_detected))\n\n# Handle images via multimodal vision\nif all_images and model_supports_vision:\n    message = self._create_multimodal_message(user_message, all_images)\nelse:\n    message = HumanMessage(content=user_message)\n\n# Handle text files (option 1: include in context)\nif text_files:\n    file_context = []\n    for file in text_files:\n        try:\n            with open(file.path, 'r', encoding='utf-8') as f:\n                content = f.read(10000)  # Limit to 10KB\n                file_context.append(f\"\\n\\n--- {Path(file.path).name} ---\\n{content}\")\n        except Exception as e:\n            logger.warning(f\"Failed to read {file.path}: {e}\")\n    \n    if file_context:\n        # Prepend file contents to message\n        enhanced_content = user_message + \"\\n\\nAttached files:\" + \"\".join(file_context)\n        if isinstance(message.content, str):\n            message.content = enhanced_content\n        # For multimodal, add text block with files\n\n# Clear attached files after sending\nself.input_area.attached_files.clear()\nself.input_area._update_file_chips()\n```\n\nFiles to create:\n- src/consoul/tui/widgets/attachment_button.py\n- src/consoul/tui/widgets/file_chip.py (renamed from image_chip.py)\n- tests/tui/widgets/test_attachment_button.py\n- tests/tui/widgets/test_file_chip.py\n\nFiles to modify:\n- src/consoul/tui/widgets/input_area.py\n- src/consoul/tui/app.py (on_input_area_message_submit)\n- src/consoul/tui/widgets/__init__.py (export new widgets)\n- src/consoul/config/models.py (optional: add attachment button config)\n\nDependencies: \n- SOUL-116 (image path detection)\n- SOUL-115 (multimodal message creation)\n- Uses existing read tool for text files",
  "status": "done",
  "type": "feature",
  "priority": "medium",
  "labels": [
    "tui",
    "enhancement",
    "ux-improvement",
    "multimodal"
  ],
  "reporter": "jared@goatbytes.io",
  "epic_id": "EPIC-007",
  "blocked_by": [],
  "blocks": [],
  "comments": [],
  "attachments": [],
  "attachment_count": 0,
  "comment_count": 0,
  "story_points": 8,
  "order": 0,
  "custom_fields": {}
}