{
  "created_at": "2025-11-13T08:38:57.330509",
  "updated_at": "2025-11-14T07:47:39.543526Z",
  "id": "SOUL-80",
  "uuid": "0b5dd5ba-0f53-48bd-ae50-9fb28dfd16a3",
  "title": "Implement core read_file tool with line numbering",
  "description": "**As a** Consoul user and AI agent\n**I want** to read file contents with line numbers and line-range control\n**So that** AI can access codebase files, documentation, and configuration for better context\n\n**Context:**\nThis is the core read tool implementation that enables AI agents to safely read text files. Research shows that successful read tools (Claude Code, Cursor, MCP servers) share these features:\n- Line-numbered output for reference (cat -n style)\n- Offset/limit parameters for large files\n- Encoding fallback for non-UTF-8 files\n- Path security validation\n- Clear error messages\n\nThe tool should be classified as RiskLevel.SAFE since it's read-only and requires no user approval (matching Claude Code behavior).\n\n**IMPORTANT**: This ticket focuses on BASELINE read semantics only. Truncation controls (max_line_length, max_output_chars) are handled entirely by SOUL-82. Keep this implementation focused on reading, encoding, security, and line numbering.\n\n**Research References:**\n- Claude Code Read tool: 2000 line default, line numbering, multimodal support\n- Cursor agent: github.com/The-Pocket/PocketFlow-Tutorial-Cursor/utils/read_file.py\n- MCP filesystem server: Path validation, MIME detection\n- Consoul bash tool pattern: src/consoul/ai/tools/implementations/bash.py\n\n**Technical Notes:**\n- Create: src/consoul/ai/tools/implementations/read.py\n- Use LangChain @tool decorator with Pydantic input schema\n- Module-level config pattern (like bash.py lines 28-51):\n  - _TOOL_CONFIG: ReadToolConfig | None = None\n  - set_read_config(config: ReadToolConfig) -> None\n  - get_read_config() -> ReadToolConfig\n- Line numbering: {line_num:6d}\\\\t{content} (Claude Code style)\n- Encoding fallback: UTF-8 → UTF-8-sig → Latin-1\n- Path security: Block .., /etc/shadow, /proc, /dev, /sys\n- Export from src/consoul/ai/tools/implementations/__init__.py\n- **Do NOT implement truncation here** - that's SOUL-82's responsibility\n\n**Acceptance Criteria:**\n\n**Given** I request to read a text file\n**When** the AI calls read_file(file_path=\"src/main.py\")\n**Then** file contents are returned with 1-based line numbers\n\n**Given** a large file (5000 lines)\n**When** I read with offset=100, limit=50\n**Then** only lines 100-149 are returned with correct line numbers\n\n**Given** a file with non-UTF-8 encoding\n**When** read_file is called\n**Then** encoding fallback succeeds and content is readable\n\n**Given** an attempt to read /etc/shadow or use ../../../\n**When** read_file is called with malicious path\n**Then** security validation blocks the read with clear error\n\n**Given** an empty file\n**When** read_file is called\n**Then** returns \"[File is empty]\" message\n\n**Given** a binary file (.exe, .zip)\n**When** read_file is called\n**Then** returns \"Unsupported binary file format\" error\n\n**Testing Considerations:**\n- Mock file system for security tests\n- Test with various encodings (UTF-8, UTF-8-BOM, Latin-1)\n- Test offset/limit edge cases (beyond EOF, negative values)\n- Test path validation extensively\n- Test empty files, missing files, directories\n- Test line number formatting consistency\n- **Truncation testing is in SOUL-82**\n\n**Implementation Hints:**\n```python\nfrom langchain_core.tools import tool\nfrom pydantic import BaseModel, Field\nfrom pathlib import Path\n\nclass ReadFileInput(BaseModel):\n    file_path: str = Field(description=\"Path to file\")\n    offset: int | None = Field(None, description=\"Start line (1-indexed)\")\n    limit: int | None = Field(None, description=\"Number of lines\")\n\n@tool(args_schema=ReadFileInput)\ndef read_file(file_path: str, offset: int | None = None, limit: int | None = None) -> str:\n    \"\"\"Read file contents with line numbers.\"\"\"\n    config = get_read_config()\n    # Implementation - NO truncation logic here\n    # Just read, encode, validate, and number lines\n    # SOUL-82 will add truncation wrapper\n```\n- Use Path.resolve() for absolute paths\n- Check blocked_paths before reading\n- Apply max_lines_default from config if no limit specified\n- Handle FileNotFoundError, PermissionError, UnicodeDecodeError\n- Return user-friendly error messages (not exceptions)\n- Return raw output - truncation happens in SOUL-82",
  "status": "done",
  "type": "feature",
  "priority": "high",
  "labels": [
    "tools",
    "ai",
    "enhancement",
    "filesystem"
  ],
  "assignee": "jared@goatbytes.io",
  "reporter": "jared@goatbytes.io",
  "epic_id": "EPIC-005",
  "blocked_by": [
    "SOUL-79"
  ],
  "blocks": [
    "SOUL-81",
    "SOUL-82",
    "SOUL-83",
    "SOUL-85"
  ],
  "comments": [
    {
      "created_at": "2025-11-13T09:50:01.262523",
      "updated_at": "2025-11-13T09:50:01.262525",
      "id": "20251113095001-7ece0322",
      "ticket_id": "SOUL-80",
      "author": "jared@goatbytes.io",
      "content": "✅ IMPLEMENTATION COMPLETE\n\n**Changes Made:**\n1. Created src/consoul/ai/tools/implementations/read.py (319 lines)\n   - Module-level config pattern (set_read_config, get_read_config)\n   - ReadFileInput Pydantic schema with file_path, offset, limit\n   - @tool decorated read_file() function\n   - Path security validation (blocks /etc/shadow, /proc, /dev, /sys, path traversal)\n   - Extension validation using config.allowed_extensions\n   - Encoding fallback chain: UTF-8 → UTF-8-sig → Latin-1\n   - Line numbering with {line_num:6d}\\t{content} format (Claude Code style)\n   - Offset/limit slicing preserving actual file line numbers\n   - Binary file detection via null byte check\n   - User-friendly error messages (no exceptions to LLM)\n   - Empty file handling: \"[File is empty]\"\n   - Directory detection: \"Cannot read directory\"\n\n2. Updated src/consoul/ai/tools/implementations/__init__.py\n   - Added read_file, get_read_config, set_read_config exports\n   - Updated __all__ list\n\n3. Created tests/ai/tools/implementations/test_read.py (420 lines)\n   - 41 comprehensive tests covering all functionality\n   - TestFormatWithLineNumbers: 5 tests\n   - TestIsBinaryFile: 4 tests\n   - TestValidatePath: 6 tests (including path traversal, blocked paths)\n   - TestValidateExtension: 4 tests\n   - TestReadWithEncodingFallback: 3 tests (UTF-8, BOM, Latin-1)\n   - TestReadFile: 19 integration tests\n\n**Verification:**\n✅ All 41 tests passing\n✅ Type checking passes (mypy)\n✅ Linting passes (ruff)\n✅ 86% code coverage for read.py\n\n**Key Design Decisions:**\n- No truncation logic (SOUL-82's responsibility per ticket)\n- Line numbers preserved with offsets (100-149, not 1-50)\n- 1-based indexing for user-facing line numbers\n- Errors returned as strings to LLM, never raised\n- Config-driven security (ReadToolConfig)\n- RiskLevel.SAFE classification (read-only, no approval needed)\n- Handles macOS symlink case (/etc → /private/etc)\n\n**Acceptance Criteria Met:**\n✅ Read text file → returns with 1-based line numbers\n✅ Large file with offset=100, limit=50 → lines 100-149 correct\n✅ Non-UTF-8 encoding → fallback succeeds\n✅ Malicious paths (/etc/shadow, ../..) → security blocks with clear error\n✅ Empty file → \"[File is empty]\" message\n✅ Binary file → \"Unsupported binary file format\" error\n\n**Files Created/Modified:**\n- src/consoul/ai/tools/implementations/read.py (+319 lines)\n- src/consoul/ai/tools/implementations/__init__.py (+13 lines)\n- tests/ai/tools/implementations/test_read.py (+420 lines)\n\n**Next Steps:**\nReady for SOUL-81 (PDF support) and SOUL-82 (truncation controls) which depend on this ticket.",
      "edited": false,
      "edit_count": 0,
      "is_ai_generated": false,
      "attachments": [],
      "attachment_count": 0
    }
  ],
  "attachments": [],
  "attachment_count": 0,
  "comment_count": 1,
  "story_points": 5,
  "order": 0,
  "custom_fields": {}
}