{
  "created_at": "2025-11-09T13:45:37.200353",
  "updated_at": "2025-11-09T13:45:37.200365",
  "id": "SOUL-27",
  "uuid": "f63e55a7-8eea-45b7-9356-52f9959571c0",
  "title": "Add SQLite conversation persistence and recovery",
  "description": "**As a** Consoul user\n**I want** my conversation history saved to SQLite\n**So that** I can resume conversations after restarting the application and review past interactions\n\n**Context:**\nPhase 1 (SOUL-26) implemented in-memory conversation history with token counting and intelligent trimming. Phase 2 adds SQLite persistence inspired by Simon Willison's LLM tool and aider's chat history storage.\n\nResearch shows:\n- LLM tool uses SQLite with conversations, responses, and attachments tables\n- Aider PR #1860 added SQLite chat history with Datasette integration\n- LangGraph uses SqliteSaver for checkpoint persistence\n- LangChain 0.3+ recommends RunnableWithMessageHistory with session IDs\n\n**Technical Notes:**\n- **Files to create**: `src/consoul/ai/persistence.py`, `src/consoul/ai/database.py`\n- **Files to modify**: `src/consoul/ai/history.py` (add persistence option)\n- **Schema design**: conversations table (id, session_id, created_at, updated_at, model, metadata)\n                     messages table (id, conversation_id, role, content, tokens, timestamp)\n- **Dependencies**: Core SQLite3 library (stdlib, no new deps needed)\n- **Integration**: ConversationHistory should support optional persistence backend\n- **Session management**: UUID-based session IDs for conversation isolation\n- **Migration path**: Existing ConversationHistory instances work without changes (opt-in)\n\n**Acceptance Criteria:**\n\n**Given** I enable persistence in configuration\n**When** I start a conversation\n**Then** a new session is created in SQLite with unique session_id\n\n**Given** I have an active conversation\n**When** I add messages to history\n**Then** each message is saved to database with role, content, tokens, and timestamp\n\n**Given** I close and restart Consoul\n**When** I request to resume a session\n**Then** full conversation history is loaded from SQLite\n\n**Given** I have multiple past conversations\n**When** I run `consoul history list`\n**Then** I see all previous sessions with metadata (date, model, message count)\n\n**Given** I want to view a past conversation\n**When** I run `consoul history show <session-id>`\n**Then** full conversation is displayed with formatted messages\n\n**Given** I want to export a conversation\n**When** I run `consoul history export <session-id> --format json`\n**Then** conversation is exported to JSON file\n\n**Given** database file exists but is corrupted\n**When** ConversationHistory attempts to load\n**Then** graceful fallback to in-memory mode with error message\n\n**Testing Considerations:**\n- Unit tests for SQLite schema creation\n- Test message CRUD operations (create, read, list, delete)\n- Test session lifecycle (create, resume, list, delete)\n- Test concurrent access (multiple Consoul instances)\n- Test database migration (schema versioning)\n- Test export/import functionality (JSON, markdown formats)\n- Test in-memory fallback on DB errors\n- Mock SQLite for unit tests, use temp DB for integration tests\n- Verify token counts are persisted correctly\n- Test with large conversation histories (10k+ messages)\n\n**Implementation Hints:**\n\n```python\n# src/consoul/ai/database.py\nimport sqlite3\nfrom pathlib import Path\nfrom typing import Optional\nfrom datetime import datetime\nimport uuid\n\nclass ConversationDatabase:\n    \"\"\"SQLite persistence for conversation history.\"\"\"\n    \n    SCHEMA_VERSION = 1\n    \n    def __init__(self, db_path: Path | str = \"~/.consoul/history.db\"):\n        self.db_path = Path(db_path).expanduser()\n        self.db_path.parent.mkdir(parents=True, exist_ok=True)\n        self._init_schema()\n    \n    def _init_schema(self):\n        \"\"\"Initialize database schema with versioning.\"\"\"\n        with sqlite3.connect(self.db_path) as conn:\n            conn.executescript(\"\"\"\n                CREATE TABLE IF NOT EXISTS schema_version (\n                    version INTEGER PRIMARY KEY\n                );\n                \n                CREATE TABLE IF NOT EXISTS conversations (\n                    id TEXT PRIMARY KEY,\n                    session_id TEXT UNIQUE NOT NULL,\n                    model TEXT NOT NULL,\n                    created_at TEXT NOT NULL,\n                    updated_at TEXT NOT NULL,\n                    metadata TEXT  -- JSON blob\n                );\n                \n                CREATE TABLE IF NOT EXISTS messages (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    conversation_id TEXT NOT NULL,\n                    role TEXT NOT NULL,\n                    content TEXT NOT NULL,\n                    tokens INTEGER,\n                    timestamp TEXT NOT NULL,\n                    FOREIGN KEY (conversation_id) REFERENCES conversations(id)\n                );\n                \n                CREATE INDEX IF NOT EXISTS idx_messages_conversation \n                    ON messages(conversation_id);\n                CREATE INDEX IF NOT EXISTS idx_conversations_session \n                    ON conversations(session_id);\n            \"\"\")\n    \n    def create_conversation(self, model: str, session_id: Optional[str] = None) -> str:\n        \"\"\"Create new conversation session.\"\"\"\n        session_id = session_id or str(uuid.uuid4())\n        now = datetime.utcnow().isoformat()\n        \n        with sqlite3.connect(self.db_path) as conn:\n            conn.execute(\n                \"INSERT INTO conversations VALUES (?, ?, ?, ?, ?, ?)\",\n                (session_id, session_id, model, now, now, \"{}\")\n            )\n        return session_id\n    \n    def save_message(self, session_id: str, role: str, content: str, tokens: int):\n        \"\"\"Save message to conversation.\"\"\"\n        now = datetime.utcnow().isoformat()\n        \n        with sqlite3.connect(self.db_path) as conn:\n            conn.execute(\n                \"INSERT INTO messages (conversation_id, role, content, tokens, timestamp) \"\n                \"VALUES (?, ?, ?, ?, ?)\",\n                (session_id, role, content, tokens, now)\n            )\n            # Update conversation updated_at\n            conn.execute(\n                \"UPDATE conversations SET updated_at = ? WHERE session_id = ?\",\n                (now, session_id)\n            )\n    \n    def load_conversation(self, session_id: str) -> list[dict]:\n        \"\"\"Load all messages for a conversation.\"\"\"\n        with sqlite3.connect(self.db_path) as conn:\n            conn.row_factory = sqlite3.Row\n            cursor = conn.execute(\n                \"SELECT role, content, tokens, timestamp FROM messages \"\n                \"WHERE conversation_id = ? ORDER BY id\",\n                (session_id,)\n            )\n            return [dict(row) for row in cursor.fetchall()]\n    \n    def list_conversations(self, limit: int = 50) -> list[dict]:\n        \"\"\"List recent conversations.\"\"\"\n        with sqlite3.connect(self.db_path) as conn:\n            conn.row_factory = sqlite3.Row\n            cursor = conn.execute(\n                \"SELECT c.session_id, c.model, c.created_at, c.updated_at, \"\n                \"COUNT(m.id) as message_count \"\n                \"FROM conversations c \"\n                \"LEFT JOIN messages m ON c.session_id = m.conversation_id \"\n                \"GROUP BY c.session_id \"\n                \"ORDER BY c.updated_at DESC LIMIT ?\",\n                (limit,)\n            )\n            return [dict(row) for row in cursor.fetchall()]\n\n# src/consoul/ai/history.py modifications\nclass ConversationHistory:\n    def __init__(\n        self,\n        model_name: str,\n        max_tokens: int | None = None,\n        model: BaseChatModel | None = None,\n        persist: bool = False,  # NEW\n        session_id: str | None = None,  # NEW\n        db_path: Path | str | None = None,  # NEW\n    ):\n        # ... existing initialization ...\n        \n        # Persistence setup\n        self.persist = persist\n        self.session_id = session_id\n        self._db: ConversationDatabase | None = None\n        \n        if persist:\n            self._db = ConversationDatabase(db_path or \"~/.consoul/history.db\")\n            if session_id:\n                # Resume existing conversation\n                self._load_from_db(session_id)\n            else:\n                # Create new session\n                self.session_id = self._db.create_conversation(model_name)\n    \n    def add_message(self, role: str, content: str) -> None:\n        \"\"\"Add message to history (with optional persistence).\"\"\"\n        msg = to_langchain_message(role, content)\n        self.messages.append(msg)\n        \n        # Persist if enabled\n        if self.persist and self._db:\n            tokens = self._token_counter([msg])\n            self._db.save_message(self.session_id, role, content, tokens)\n```\n\n**CLI Commands to Add:**\n\n```bash\n# List conversation history\nconsoul history list [--limit 50]\n\n# Show specific conversation\nconsoul history show <session-id> [--format text|json|markdown]\n\n# Resume conversation\nconsoul chat --resume <session-id>\n\n# Export conversation\nconsoul history export <session-id> [--format json|markdown] [-o output.json]\n\n# Delete conversation\nconsoul history delete <session-id>\n\n# Clear all history (with confirmation)\nconsoul history clear [--force]\n\n# Database stats\nconsoul history stats\n```\n\n**Configuration:**\n\n```yaml\n# ~/.config/consoul/config.yaml\nhistory:\n  persist: true  # Enable SQLite persistence (default: false)\n  db_path: ~/.consoul/history.db\n  auto_resume: false  # Auto-resume last conversation on startup\n  retention_days: 90  # Auto-delete conversations older than N days (0 = keep forever)\n```\n\n**Migration from Phase 1:**\n- Existing ConversationHistory usage works without changes (persist=False by default)\n- Examples continue to work in memory-only mode\n- Users opt-in to persistence via config or CLI flag\n\n**Future Enhancements (Phase 3+):**\n- Datasette integration for browsing history (like aider)\n- Full-text search across conversations\n- Conversation summarization for archival\n- Export to different formats (HTML, PDF)\n- Conversation forking/branching",
  "status": "todo",
  "type": "feature",
  "priority": "high",
  "labels": [
    "ai",
    "persistence",
    "history",
    "database"
  ],
  "reporter": "jared@goatbytes.io",
  "epic_id": "EPIC-002",
  "blocked_by": [],
  "blocks": [],
  "comments": [],
  "attachments": [],
  "attachment_count": 0,
  "comment_count": 0,
  "story_points": 8,
  "order": 0,
  "custom_fields": {}
}