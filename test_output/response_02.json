{
  "prompt": "Explain the difference between abstract classes and interfaces in Java",
  "response": "In Java, both abstract classes and interfaces are used to define a contract for other classes to implement, but they have some key differences:\n\n### Abstract Classes\n\n- **Definition**: An abstract class is a class that contains one or more abstract methods. Abstract methods are methods declared without an implementation (i.e., without method body).\n  \n- **Inheritance**: A Java class can extend only one abstract class.\n\n- **Method Implementation**: Abstract classes can have concrete methods with implementations.\n\n- **Example**:\n  ```java\n  public abstract class Animal {\n      protected String name;\n\n      public Animal(String name) {\n          this.name = name;\n      }\n\n      public void eat() {\n          System.out.println(name + \" is eating.\");\n      }\n\n      // This method must be implemented by any subclass\n      public abstract void makeSound();\n  }\n  ```\n\n### Interfaces\n\n- **Definition**: An interface defines a set of methods that classes can implement. Like abstract methods, these are declared without an implementation.\n\n- **Inheritance**: A class can implement multiple interfaces.\n\n- **No Concrete Methods**: Interfaces cannot contain any concrete (implemented) methods except for default (`public` by default) and static methods starting from Java 8.\n\n- **Example**:\n  ```java\n  public interface Animal {\n      void makeSound();\n      \n      // Default method in interfaces since Java 8\n      default void getDefaultMethod() {\n          System.out.println(\"Default behavior.\");\n      }\n  }\n  ```\n\n### Key Differences\n\n1. **Abstract Classes**: Can contain both abstract and concrete methods.\n2. **Interfaces**: Only consist of abstract methods (or, from Java 8 onwards, default and static methods).\n3. **Inheritance**: A class can extend only one abstract class but implement multiple interfaces.\n4. **Implementation**: Abstract classes provide some level of implementation which subclasses may inherit or override. Interfaces do not provide any implementation; they only specify what must be implemented by the implementing class.\n\n### When to Use\n\n- **Abstract Classes** when you need to share code among several closely related classes that differ mainly in terms of data types handled.\n  \n- **Interfaces** when you want to define a contract for unrelated classes. For example, `Runnable` is an interface used to execute tasks concurrently.\n\n### Example Usage\n\n```java\npublic class Dog extends Animal {\n    public Dog(String name) {\n        super(name);\n    }\n\n    @Override\n    public void makeSound() {\n        System.out.println(\"Dog says: Bow!\");\n    }\n}\n```\n\nIn this example, `Dog` is an abstract class that extends the `Animal` abstract class. It provides its own implementation for the `makeSound()` method and inherits the default behavior defined in the abstract class.\n\n```java\npublic interface Bird {\n    void makeSound();\n\n    // Default method available since Java 8\n    default void fly() {\n        System.out.println(\"Bird is flying.\");\n    }\n}\n\nclass Sparrow implements Bird {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Sparrow says: Chirp!\");\n    }\n}\n```\n\nHere, `Sparrow` implements the `Bird` interface and provides its own implementation for `makeSound()`.\n\n### Conclusion\n\nAbstract classes and interfaces are both powerful tools in Java for defining contracts. The choice between them depends on whether you need to share some implementation among subclasses or define a contract that unrelated classes can implement.",
  "error": null,
  "timestamp": "2025-11-28T22:27:15.278908",
  "model": "granite4:3b",
  "success": true
}
